/* *  V2XE Example.c *   * *  Created by John Gonzaga on Thu Dec 18 2003. *  Copyright (c) 2003 PNI Corporation. All rights reserved. * *  This function is an example to retrieve all the V2Xe data *  in one single frame. * */#define kSyncChar   0xAA#define kTerminator 0x00enum{    // commands/frame types    kGetModInfo = 1,    // 0x01    kModInfoResp,       // 0x02     kSetDataComponents, // 0x03     kGetData,           // 0x04    kDataResp,          // 0x05    kSetConfig,         // 0x06    kGetConfig,         // 0x07    kConfigResp,        // 0x08    kSaveConfig,        // 0x09    kStartCal,          // 0x0A    kStopCal,           // 0x0B    kGetCalData,        // 0x0C    kCalDataResp,       // 0x0D    kSetCalData,        // 0x0E    // data types    kRawX = 1,          // 0x01    kRawY,              // 0x02    kCalibratedX,       // 0x03    kCalibratedY,       // 0x04    kHeading,           // 0x05    kMagnitude,         // 0x06    kTemperature,       // 0x07    kDistortion,        // 0x08    kCalStatus,         // 0x09    // config types    kDeclination = 1,   // 0x01    kTrueNorth,         // 0x02    kCalSampleFreq,     // 0x03    kSampleFreq,        // 0x04    kPeriod,            // 0x05    kBigEndian,         // 0x06    kDampingSize,       // 0x07    // cal data types    kXOffset = 1,       // 0x01    kYOffset,           // 0x02    kXGain,             // 0x03    kYGain,             // 0x04    kPhi,               // 0x05    kCalMagnitude       // 0x06};typedef struct{    SInt32 x, y;    float xe, ye;    float heading, magnitude;    float temperature;    UInt8 distortion, calStatus;} V2XEData;UInt8 SPITransmit(UInt8 byte){    // transmit byte through SPI        // add code to transmit byte through hardware    // or software bit-banging         // ... then return the byte receive    return byte;}void GetData(V2XEData * data){    UInt8 index, count, type, buffer[64];    UInt8 *ptr;        index = 0;        // send SendDataComponents command to get all the data    // the order of the components        buffer[index++] = kSyncChar;            // all frames always start with a sync character    buffer[index++] = kSendDataComponents;  // the frame type    buffer[index++] = 9;                    // number of components to retrieve    buffer[index++] = kRawX;                // followed by the component identifiers    buffer[index++] = kRawY;                // ... the order of the identifiers    buffer[index++] = kCalibratedX;         // ... will the same in the response    buffer[index++] = kCalibratedY;         // ... frame, DataResp    buffer[index++] = kHeading;    buffer[index++] = kMagnitude;    buffer[index++] = kTemperature;    buffer[index++] = kDistortion;    buffer[index++] = kCalStatus;    buffer[index++] = kTerminator;          // don't forget the terminator    // now transmit the command    count = index;    index = 0;    while(count--)    {        // just throw away whatever is receive        SPITransmit(buffer[index++]);    }    // now poll the response by looking for the response SyncChar    while(SPITransmit(0) == kSyncChar);    // the next byte will be the response frame type    if(SPITransmit(0) == kDataResp)    {        // the next byte will be the data component count        count = SPITransmit(0);        while(count--)        {            // get the component data identifier            type = SPITransmit(0);            switch(type)            {                case kRawX:                 {                    // point ptr to where to store the data                    ptr = &data->x;                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    // the SInt32 raw X count is now stored in data->x                    // ... the V2Xe can return in little endian or big endian                     // ... format, so prior to any transmission set the                     // ... V2Xe endian format                    break;                }                case kRawY:                 {                    ptr = &data->y;                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    break;                }                case kCalibratedX:                 {                    ptr = &data->xe;                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    break;                }                case kCalibratedY:                 {                    ptr = &data->ye;                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    break;                }                case kHeading:                 {                    ptr = &data->heading;                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    break;                }                case kMagnitude:                 {                    ptr = &data->magnitude;                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    break;                }                case kTemperature:                 {                    ptr = &data->temperature;                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    *ptr++ = SPITransmit(0);                    break;                }                case kDistortion:                 {                    data->distortion = SPITransmit(0);                    break;                }                case kDistortion:                 {                    data->calStatus = SPITransmit(0);                    break;                }                                default:                {                    // error condition                     break;                }            }        }    }}

